# Understand our Security Requirements

¿A quién se le debería permitir administrar cualquier `CashCard`?

En nuestro dominio simple, indiquemos que el usuario que creó la `CashCard` es "Owner" de la misma. Por lo tanto, es el "propietario de la `CashCard`". Solo el propietario puede verla o actualizarla.

La lógica será algo así:

```java
IF the user is _authenticated_

... AND they are _authorized_ as a "card owner"

... ... AND they own the requested Cash Card

THEN complete the users's request

BUT don't allow users to access Cash Cards they do not own.
```

# Review update from Previous Lab

En este laboratorio aseguraremos nuestra **API** de **Family Cash Card** y restringiremos el acceso a cualquier `CashCard` dada al "owner".

Para prepararnos para esto, presentamos el concepto de propietario en la solicitud.

El propietario es la identidad única de la persona que creó y puede administrar una `CashCard` determinada.

Revisemos los siguientes cambios que hicimos en su nombre:

- `owner` se agregó como un campo al registro **Java** de `CashCard`.

```java
package example.cashcard;

import org.springframework.data.annotation.Id;

record CashCard(@Id Long id, Double amount, String owner) {
}
```

- `owner` añadido a todos los archivos `.sql` en `src/main/resources/` y `src/test/resources/`.

`src/main/resources/shema.sql`:

```sql
CREATE TABLE cash_card
(
    ID       BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    AMOUNT   NUMBER NOT NULL DEFAULT 0,
    OWNER    VARCHAR(256) NOT NULL
);
```

`src/test/resources/data.sql`:

```sql
INSERT INTO CASH_CARD(ID, AMOUNT, OWNER) VALUES (99, 123.45, 'sarah1');

INSERT INTO CASH_CARD(ID, AMOUNT, OWNER) VALUES (100, 1.00, 'sarah1');

INSERT INTO CASH_CARD(ID, AMOUNT, OWNER) VALUES (101, 150.00, 'sarah1');
```

- `owner` añadido a todos los archivos `.json` en `src/test/resources/example/cashcard`.

`src/test/resources/example/cashcard/list.json`:

```json
[
  {"id": 99, "amount": 123.45 , "owner": "sarah1"},
  {"id": 100, "amount": 1.00 , "owner": "sarah1"},
  {"id": 101, "amount": 150.00, "owner": "sarah1" }
]
```

`src/test/resources/example/cashcard/single.json`:

```json
{
  "id": 99,
  "amount": 123.45,
  "owner": "sarah1"
}
```

Todo el código de la aplicación y las pruebas se actualizan para admitir el campo del nuevo propietario. Ninguna funcionalidad ha cambiado como resultado de estas actualizaciones.

Tomemos un tiempo para familiarizarnos con estas actualizaciones.

# Add the Spring Security Dependency

Podemos añadir soporte para **Spring Security** añadiendo la dependencia adecuada.

### 1. Añade la dependencia.

Añade lo siguiente al archivo `build.gradle` en la sección de dependencias `{}`:

```groovy
    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter-web'
    
        // Add the following dependency
        implementation 'org.springframework.boot:spring-boot-starter-security'
        ...
```

### 2. Ejecuta las pruebas.

Hemos añadido capacidades de **Spring Security** a nuestra aplicación, pero no hemos cambiado ningún código.

Entonces, ¿qué esperamos que suceda cuando ejecutemos las pruebas?

Tenga en cuenta que siempre ejecutaremos `./gradlew test` para ejecutar las pruebas.

```shell
[~/exercises] $ ./gradlew test
...
CashCardApplicationTests > shouldReturnASortedPageOfCashCards() FAILED
...
CashCardApplicationTests > shouldReturnACashCardWhenDataIsSaved() FAILED
...
CashCardApplicationTests > shouldCreateANewCashCard() FAILED
...
CashCardApplicationTests > shouldReturnAPageOfCashCards() FAILED
...
CashCardApplicationTests > shouldReturnAllCashCardsWhenListIsRequested() FAILED
...
CashCardApplicationTests > shouldReturnASortedPageOfCashCardsWithNoParametersAndUseDefaultValues() FAILED
...
CashCardApplicationTests > shouldNotReturnACashCardWithAnUnknownId() FAILED
11 tests completed, 7 failed
> Task :test FAILED
```

¡Las cosas están realmente rotas!

Todos los métodos de prueba dentro de `CashCardApplicationTests` fallaron.

Muchos fracasos son similares al siguiente:

```shell
expected: <SOME NUMBER>
 but was: 0
```

En la mayoría de los casos, nuestras pruebas esperan que los datos de `CashCard` sean devueltos desde nuestra **API**, pero no se devolvió nada.

¿Por qué crees que todas las pruebas de nuestra **API** de `CashCard` están fallando después de añadir la dependencia de Spring Security?

### 3. Entiende por qué todo está roto.

¿Qué ha pasado aquí?

Cuando añadimos la dependencia de **Spring Security** a nuestra aplicación, la seguridad estaba habilitada de forma predeterminada.

Dado que no hemos especificado cómo se realiza la autenticación y la autorización dentro de nuestra **API** de `CashCard`, **Spring Security** ha bloqueado completamente nuestra **API**.

Bueno, más vale prevenir que lamentar, ¿verdad?

A continuación, configuremos **Spring Security** para nuestra aplicación.

# Satisfy Spring Security's Dependencies

A continuación, nos centraremos en volver a arreglar nuestras pruebas proporcionando la configuración mínima necesaria para **Spring Security**.

Hemos proporcionado otro archivo en nuestro nombre: `example/cashcard/SecurityConfig.java`. Este será el **Java Bean** donde configuraremos **Spring Security** para nuestra aplicación.

```java
package example.cashcard;

//import org.springframework.context.annotation.Bean;
//import org.springframework.context.annotation.Configuration;
//import org.springframework.security.config.Customizer;
//import org.springframework.security.config.annotation.web.builders.HttpSecurity;
//import org.springframework.security.core.userdetails.User;
//import org.springframework.security.core.userdetails.UserDetails;
//import org.springframework.security.core.userdetails.UserDetailsService;
//import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
//import org.springframework.security.crypto.password.PasswordEncoder;
//import org.springframework.security.provisioning.InMemoryUserDetailsManager;
//import org.springframework.security.web.SecurityFilterChain;

class SecurityConfig {
//
//    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
//        return http.build();
//    }
//
//    @Bean
//    PasswordEncoder passwordEncoder() {
//        return new BCryptPasswordEncoder();
//    }
}
```

### 1. Descomente `SecurityConfig.java` y revise.

Abre `SecurityConfig.java`.

Tenga en cuenta que la mayor parte del archivo está comentado.

Descomente todas las líneas comentadas dentro de `SecurityConfig`, incluidos todos los métodos y las declaraciones de importación.

```java
package example.cashcard;
...
class SecurityConfig {

    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http.build();
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
...
```

`filterChain` devuelve `http.build()`, que es el mínimo necesario por ahora.

Nota: Por favor, ignore el método `passwordEncoder()` por ahora.

### 2. Habilitar **Spring Security**.

Por el momento, `SecurityConfig` es solo una clase **Java** sin referencia, ya que nada la está usando.

Vamos a convertir `SecurityConfig` en nuestra configuración **Bean** para **Spring Security**.

```java
    // Add this Annotation
    @Configuration
    class SecurityConfig {
    
        // Add this Annotation
        @Bean
        SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
            return http.build();
        }
    ...
```

### 3. Entender las anotaciones.

```java
@Configuration
class SecurityConfig {...}
```

La anotación `@Configuration` le dice a **Spring** que use esta clase para configurar **Spring** y **Spring Boot** en sí. Cualquier bean especificado en esta clase ahora estará disponible para el motor de configuración automática de **Spring**.

```java
@Bean
SecurityFilterChain filterChain
```

**Spring Security** espera que un bean configure su cadena de filtros, de la que aprendiste en la lección de **Simple Spring Security**. Anotar un método que devuelve una cadena de filtros de seguridad con el `@Bean` satisface esta expectativa.

### 4. Correr las pruebas.

Cuando ejecutes las pruebas, verás que una vez más todas las pruebas pasan, excepto la prueba para crear una nueva `CashCard` a través de un **POST**.

```shell
[~/exercises] $ ./gradlew test
...
CashCardApplicationTests > shouldCreateANewCashCard() FAILED
    org.opentest4j.AssertionFailedError:
    expected: 201 CREATED
     but was: 403 FORBIDDEN
...
11 tests completed, 1 failed
```

Esto se espera. Cubriremos esto en profundidad un poco más adelante.

# Configure Basic Authentication

Hasta ahora hemos arrancado **Spring Security**, pero en realidad no hemos asegurado nuestra aplicación.

Ahora aseguremos nuestra aplicación configurando la autenticación básica.

### 1. Configurar la autenticación básica.

Actualice `SecurityConfig.filterChain` con lo siguiente para habilitar la autenticación básica:

```java
    @Bean
    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
         http
                 .authorizeHttpRequests(request -> request
                         .requestMatchers("/cashcards/**")
                         .authenticated())
                 .httpBasic(Customizer.withDefaults())
                 .csrf(csrf -> csrf.disable());
         return http.build();
    }
```

### 2. Comprender la configuración de **Spring Security**.

¡Son muchas llamadas de método!

Aquí, si explicamos el patrón de construcción de **Spring Security** en un lenguaje más comprensible, vemos:

> All HTTP requests to `cashcards/` endpoints are required to be authenticated using HTTP Basic Authentication security (username and password).
> Also, do not require CSRF security.

> Todas las solicitudes **HTTP** a endpoints de `cashcard/` deben autenticarse utilizando la seguridad de la autenticación básica **HTTP** (nombre de usuario y contraseña).
> Además, no requiere seguridad **CSRF**.

Nota: Hablaremos sobre la seguridad de **CSRF** más adelante en este laboratorio.

### 3. Ejecuta las pruebas.

¿Qué pasará cuando hagamos nuestras pruebas?

Cuando ejecute las pruebas, notará que la mayoría de las pruebas fallan con un código de estado `HTTP 401 UNAUTHORIZED`, como el siguiente:

```shell
[~/exercises] $ ./gradlew test
...
expected: 200 OK
  but was: 401 UNAUTHORIZED
```

Aunque puede que no lo parezca, ¡esto es progreso!

Hemos habilitado la autenticación básica, lo que requiere que las solicitudes proporcionen un nombre de usuario y una contraseña.

Nuestras pruebas no proporcionan un nombre de usuario y una contraseña con nuestras solicitudes **HTTP**. Así que haz eso a continuación.

# Testing Basic Authentication

Como aprendimos en la lección que lo acompaña, hay muchas maneras de proporcionar información de autenticación y autorización del usuario para una aplicación **Spring Boot** utilizando **Spring Security**.

Para nuestras pruebas, configuraremos un servicio de solo prueba que **Spring Security** utilizará para este propósito: Un `InMemoryUserDetailsManager`.

Al igual que configuramos una base de datos en memoria usando **H2** para probar **Spring Data**, configuraremos un servicio en memoria con usuarios de prueba para probar **Spring Security**.

### 1. Configure un servicio de detalles de usuario de solo prueba.

¿Qué nombre de usuario y contraseña debemos enviar en nuestras solicitudes **HTTP** de prueba?

Cuando revisaste los cambios en `src/test/resources/data.sql`, deberías haber visto que establecemos un valor de `OWNER` para cada `CashCard` en la base de datos con el nombre de usuario `sarah1`. Por ejemplo:

```sql
INSERT INTO CASH_CARD(ID, AMOUNT, OWNER) VALUES (100, 1.00, 'sarah1');
```

Proporcionemos un servicio de detalles de usuario solo para pruebas con el usuario `sarah1`.

Añade el siguiente **Bean** a `SecurityConfig`.

```java
  @Bean
  UserDetailsService testOnlyUsers(PasswordEncoder passwordEncoder) {
   User.UserBuilder users = User.builder();
   UserDetails sarah = users
     .username("sarah1")
     .password(passwordEncoder.encode("abc123"))
     .roles() // No roles for now
     .build();
   return new InMemoryUserDetailsManager(sarah);
  }
```

Esta configuración de `UserDetailsService` debería ser comprensible: configure un usuario llamado `sarah1` con la contraseña `abc123`.

El contenedor **IoC** de **Spring** encontrará el `UserDetailsService` **Bean** y **Spring Data** lo usará cuando sea necesario.

### 2. Configurar la autenticación básica en las pruebas **HTTP**.

Seleccione un método de prueba que utilice `restTemplate.getForEntity` y actualícelo con la autenticación básica para `sarah1`.

```java
    void shouldReturnACashCardWhenDataIsSaved() {
        ResponseEntity<String> response = restTemplate
                .withBasicAuth("sarah1", "abc123") // Add this
                .getForEntity("/cashcards/99", String.class);
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        ...
```

### 3. Ejecuta las pruebas.

¡La prueba actualizada que proporciona lo básico ahora debería pasar!

```shell
    [~/exercises] $ ./gradlew test
    ...
    CashCardApplicationTests > shouldReturnACashCardWhenDataIsSaved() PASSED
    ...
```

### 4. Actualice todas las pruebas restantes de `CashCardApplicationTests` y vuelva a ejecutar las pruebas.

Ahora, para un poco de tedio: Actualice todas las pruebas restantes basadas en `restTemplate` para proporcionar `.withBasicAuth("sarah1", "abc123")` con cada solicitud **HTTP**.

Cuando termines corre los test.

```shell
[~/exercises] $ ./gradlew test
...
BUILD SUCCESSFUL in 9s
```

¡Todo pasa!

¡Enhorabuena, has implementado y probado la autenticación básica!

### 5. Verifique la autenticación básica con pruebas adicionales.

Ahora agreguemos pruebas que esperan una respuesta `401 UNAUTHORIZED` cuando se envían credenciales incorrectas utilizando la autenticación básica.

```java
@Test
void shouldNotReturnACashCardWhenUsingBadCredentials() {
    ResponseEntity<String> response = restTemplate
      .withBasicAuth("BAD-USER", "abc123")
      .getForEntity("/cashcards/99", String.class);
    assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);

    response = restTemplate
      .withBasicAuth("sarah1", "BAD-PASSWORD")
      .getForEntity("/cashcards/99", String.class);
    assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
}
```

Este test deberia pasar...

```shell
    [~/exercises] $ ./gradlew test
    ...
    CashCardApplicationTests > shouldNotReturnACashCardWhenUsingBadCredentials() PASSED
```

¡Éxito! Ahora que hemos implementado la autenticación, pasemos a implementar la autorización a continuación.

# Support Authorization

Como aprendimos en la lección que lo acompaña, **Spring Security** es compatible con muchas formas de autorización.

Aquí implementaremos el **Role-Based Access Control** (RBAC).

Es probable que un servicio de usuario proporcione acceso a muchos usuarios autenticados, pero solo se debe permitir a los "`CashCard OWNERS`" 
acceder a las **Family Cash Card** administradas por nuestra aplicación. Hagamos esas actualizaciones ahora.

### 1. Añade usuarios y roles al `UserDetailsService Bean`.

Para probar la autorización, necesitamos varios usuarios de prueba con una variedad de roles.

Actualice `SecurityConfig.testOnlyUsers` y agregue el rol de `CARD_OWNER` a `sarah1`.

Además, agreguemos un nuevo usuario llamado "`hank-owns-no-cards`" con el rol de `NON_OWNER`.

```java
    ...
    @Bean
    UserDetailsService testOnlyUsers(PasswordEncoder passwordEncoder) {
      User.UserBuilder users = User.builder();
      UserDetails sarah = users
        .username("sarah1")
        .password(passwordEncoder.encode("abc123"))
        .roles("CARD-OWNER") // new role
        .build();
      UserDetails hankOwnsNoCards = users
        .username("hank-owns-no-cards")
        .password(passwordEncoder.encode("qrs456"))
        .roles("NON-OWNER") // new role
        .build();
      return new InMemoryUserDetailsManager(sarah, hankOwnsNoCards);
    }
```

### 2. Prueba para la verificación del rol.

Agreguemos una prueba que fallará al principio, pero que pasará cuando implementemos completamente la autorización.

Aquí, afirmaremos que el usuario "`hank-owns-no-cards`" no debería tener acceso a una `CashCard`, ya que ese usuario no es un `CARD_OWNER`.

```java
@Test
void shouldRejectUsersWhoAreNotCardOwners() {
    ResponseEntity<String> response = restTemplate
      .withBasicAuth("hank-owns-no-cards", "qrs456")
      .getForEntity("/cashcards/99", String.class);
    assertThat(response.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
}
```

¡Pero espera! `CashCard` con `ID` `99` pertenece a `sarah1`, ¿verdad? ¿No debería solo `sarah1` tener acceso a esos datos independientemente de su función?

¡Tienes razón! Tenlo en cuenta para más adelante en este laboratorio.

### 3. Ejecuta las pruebas.

Vemos que nuestra nueva prueba falla cuando la ejecutamos.

```shell
[~/exercises] $ ./gradlew test
...
CashCardApplicationTests > shouldRejectUsersWhoAreNotCardOwners() FAILED
 org.opentest4j.AssertionFailedError:
 expected: 403 FORBIDDEN
  but was: 200 OK
```

¿Por qué `hank-owns-no-cards` pudo acceder a una `CashCard` como se indica en la respuesta de `200 OK`?

Aunque hemos dado a los usuarios de prueba roles, no estamos haciendo cumplir la seguridad basada en roles.

### 4. Habilitar la seguridad basada en roles.

Edite `SecurityConfig.filterChain` para restringir el acceso solo a los usuarios con el rol de `CARD_OWNER`

```java
    @Bean
    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
         http
                 .authorizeHttpRequests(request -> request
                         .requestMatchers("/cashcards/**")
                         .hasRole("CARD-OWNER")) // enable RBAC: Replace the .authenticated() call with the hasRole(...) call.
                 .httpBasic(Customizer.withDefaults())
                 .csrf(csrf -> csrf.disable());
         return http.build();
    }
```

### 5. Ejecuta las pruebas.

¡Vemos que nuestras pruebas pasan!

```shell
    [~/exercises] $ ./gradlew test
    ...
    CashCardApplicationTests > shouldRejectUsersWhoAreNotCardOwners() PASSED
```

Ahora hemos habilitado con éxito la autorización basada en RBAC!

# Cash Card ownership: Repository Updates

Como se mencionó en el ejercicio anterior, tenemos un evidente agujero de seguridad en nuestra solicitud.

¡Cualquier usuario autenticado con el rol de `CARD_OWNER` puede ver las `CashCard` familiares de cualquier otra persona!

Para solucionar esto, actualizaremos nuestras pruebas, `CashCardRepository` y `CashCardController`:

- Añadiremos funcionalidad a `CashCardRepository` para restringir las consultas al `OWNER` correcto.

- A continuación, actualizaremos nuestro CashCardController para garantizar que solo se utilice el PROPIETARIO correcto.

#### Learning Moment: Best Practices

¡Espera! ¿Este laboratorio no tiene que ver con el proyecto **Spring Security** y su increíble tecnología? ¿**Spring Security** no puede hacer toda esta validación de la propiedad para que no tengamos que modificar nuestros repositorios y controladores?

Respuesta: Este laboratorio y la lección asociada tratan sobre la seguridad de una **API HTTP**. Sí, las tecnologías de seguridad como **Spring Security** son increíbles. Sí, hay características como **Spring Security Method Security** que podrían ayudar en esta situación, pero sigue siendo su responsabilidad como desarrollador escribir código seguro y seguir las mejores prácticas de seguridad. Por ejemplo, ¡no escribas código que permita a los usuarios acceder a los datos de otros usuarios!

Ahora, actualicemos nuestras pruebas y `CashCardRepository`.

### 1. Añade una nueva `CashCard` para un usuario llamado `kumar2`.

Actualice `src/test/resources/data.sql` con un registro de `CashCard` propiedad de un usuario diferente:

```sql
    ...
    INSERT INTO CASH_CARD(ID, AMOUNT, OWNER) VALUES (102, 200.00, 'kumar2');
```

### 2. Prueba que los usuarios no pueden acceder a los datos de los demás.

Agreguemos una prueba que afirma explícitamente que nuestra `API` devuelve un `404 NOT_FOUND` cuando un usuario intenta acceder a una `CashCard` que no posee.

Nota: Es posible que se pregunte por qué queremos devolver una respuesta `404 NOT_FOUND` en lugar de otra cosa, como `401 NOT_AUTHORIZED`. Un argumento a favor de elegir devolver `NOT_FOUND` es que es la misma respuesta que devolveríamos si la `CashCard` solicitada no existe. Es más seguro equivocarse por el lado de no revelar ninguna información sobre datos que no esté autorizado para el usuario.

Ahora haremos que `sarah1` intente acceder a los datos de `kumar2`.

```java
    @Test
    void shouldNotAllowAccessToCashCardsTheyDoNotOwn() {
        ResponseEntity<String> response = restTemplate
          .withBasicAuth("sarah1", "abc123")
          .getForEntity("/cashcards/102", String.class); // kumar2's data
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
    }
```

### 3. Ejecuta las pruebas.

¿Qué crees que pasará cuando ejecutemos las pruebas? Vamos a averiguarlo.

Como era de esperar, nuestra nueva prueba falla, junto con muchas otras.

```shell
CashCardApplicationTests > shouldNotAllowAccessToCashCardsTheyDoNotOwn() FAILED
 org.opentest4j.AssertionFailedError:
 expected: 404 NOT_FOUND
  but was: 200 OK
```

¿Qué pasa aquí?

Respuesta: Actualmente, el usuario `sarah1` puede ver los datos de `kumar2` porque:

- `sarah1` está autenticada.

- `sarah1` es un `CARD_OWNER` autorizado.

Además, nuestra prueba para obtener una lista de `CashCards` también está fallando:

```shell
CashCardApplicationTests > shouldReturnAllCashCardsWhenListIsRequested() FAILED
 org.opentest4j.AssertionFailedError:
 expected: 3
  but was: 4
```

¿Por qué devolvemos demasiadas `CashCard`? Por la misma razón que la anterior: `sarah1` tiene acceso a los datos de `kumar2`. La `CashCard` de `kumar2` se devuelve a la lista de `CashCard` de `sarah1`.

Evitemos que los usuarios accedan a los datos de los demás.

### 4. Actualice el `CashCardRepository` con nuevos métodos `findBy`....

Lo más sencillo que podemos hacer es filtrar siempre nuestro acceso a los datos por parte del propietario de `CashCard`.

Hagámoslo en nuestro repositorio.

Tendremos que filtrar por propietario cuando encontremos una sola `CashCard` o una lista de `CashCard`.

Edita `CashCardRepository` para añadir dos nuevos métodos de búsqueda.

Asegúrese de incluir las nuevas importaciones para **Page** y **PageRequest**.

```java
...
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
...

interface CashCardRepository extends CrudRepository<CashCard, Long>, PagingAndSortingRepository<CashCard, Long> {
   CashCard findByIdAndOwner(Long id, String owner);
   Page<CashCard> findByOwner(String owner, PageRequest pageRequest);
}
```

Como se mencionó en los laboratorios y lecciones de **Spring Data**, **Spring Data** se encargará de las implementaciones reales (escribir las consultas **SQL**) para nosotros.

Nota: Es posible que se pregunte si **Spring Data** le permite escribir su propio **SQL**. Después de todo, **Spring Data** no puede anticipar todas las necesidades, ¿verdad? ¡La respuesta es sí! Es fácil para ti escribir tu propio código **SQL**. La documentación de **Spring Data** **Query Methods** describe cómo hacerlo utilizando la anotación `@Query`.

Sin embargo, **Spring Data** es perfectamente capaz de generar el **SQL** para las consultas que necesitamos. ¡Gracias, `Spring Data`!

A continuación, actualicemos el controlador.

# Cash Card ownership: Controller Updates

El `CashCardRepository` ahora admite el filtrado de los datos de `CashCard` por propietario.

Pero no estamos usando esta nueva funcionalidad. Hagamos esas actualizaciones al `CashCardController` ahora introduciendo un concepto que explicamos en la lección escrita: el Director.

Al igual que con otros objetos útiles, el Director está disponible para que lo usemos en nuestro Controlador. El Director tiene la información autenticada y autorizada de nuestro usuario.

### 1. Actualice el endpoint `GET` by `ID` del controlador.

Actualice el `CashCardController` para pasar la información del principal al nuevo método `findByIdAndOwner` de nuestro repositorio.

Asegúrese de añadir la nueva declaración de importación.

```java
import java.security.Principal;
...

@GetMapping("/{requestedId}")
private ResponseEntity<CashCard> findById(@PathVariable Long requestedId, Principal principal) {
    Optional<CashCard> cashCardOptional = Optional.ofNullable(cashCardRepository.findByIdAndOwner(requestedId, principal.getName()));
    if (cashCardOptional.isPresent()) {
     ...
```

Tenga en cuenta que `principal.getName()` devolverá el nombre de usuario proporcionado por **Basic Auth**.

### 2. Ejecuta las pruebas.

El `GET` está pasando, pero nuestras pruebas para las listas de `CashCard` están fallando.

```shell
    CashCardApplicationTests > shouldReturnASortedPageOfCashCards() FAILED
    ...
    CashCardApplicationTests > shouldReturnACashCardWhenDataIsSaved() PASSED
    ...
    CashCardApplicationTests > shouldReturnAllCashCardsWhenListIsRequested() FAILED
    ...
    CashCardApplicationTests > shouldReturnASortedPageOfCashCardsWithNoParametersAndUseDefaultValues() FAILED
    ...
```

### 3. Actualice el endpoint `GET` del controlador para las listas.

Edite `CashCardController` para filtrar las listas por propietario.

```java
@GetMapping
private ResponseEntity<List<CashCard>> findAll(Pageable pageable, Principal principal) {
    Page<CashCard> page = cashCardRepository.findByOwner(principal.getName(),
            PageRequest.of(
                pageable.getPageNumber(),
                ...
```

Una vez más, obtenemos el nombre de usuario autenticado del método `principal.getName()`.

### 4. Ejecuta las pruebas.

¡Todos pasan!

```shell
    BUILD SUCCESSFUL in 8s
```
# Cash Card ownership: Creation Updates

Nos queda un agujero de seguridad más: la creación de `CashCards`.

El Principal autorizado y autenticado debe usarse como propietario al crear una nueva `CashCard`.

Pregunta: ¿Qué pasaría si usáramos automáticamente el valor del propietario enviado?
Respuesta: ¡Corremos el riesgo de permitir que los usuarios creen `CashCards` para otra persona!

Asegurémonos de que solo el Principal autorizado y autenticado sea propietario de las `CashCards` que está creando.

### 1. Actualice la prueba **POST**.

Para demostrar que no necesitamos enviar un propietario, usemos null como propietario de `CashCard`.

```java
void shouldCreateANewCashCard() {
  CashCard newCashCard = new CashCard(null, 250.00, null);
  ...
```

### 2. Ejecute las pruebas.

¿Qué crees que pasará cuando hagamos las pruebas? Probablemente fracasarán, pero ¿puedes adivinar por qué?

Para ayudarnos, pasa el indicador `--info` cuando ejecutes las pruebas para que podamos obtener un poco más de información sobre lo que está sucediendo:

```shell
[~/exercises] $ ./gradlew test --info
...
CashCardApplicationTests > shouldCreateANewCashCard() FAILED
 org.opentest4j.AssertionFailedError:
 expected: 201 CREATED
  but was: 403 FORBIDDEN
```

Verás que las pruebas fallan con un error `403 FORBIDDEN`.
¿Pero por qué? Buscando en el stacktrace encontramos lo siguiente:

```shell
DbActionExecutionException: Failed to execute 
InsertRoot{entity=CashCard[id=null, amount=250.0, owner=null], idValueSource=GENERATED}] with root cause

org.h2.jdbc.JdbcSQLIntegrityConstraintViolationException: NULL not allowed for column "OWNER"; SQL statement:
INSERT INTO "CASH_CARD" ("AMOUNT", "OWNER") VALUES (?, ?) [23502-214]
```
¡Interesante! Parece que intentamos crear una nueva `CASH_CARD` en la base de datos, pero `NULL` no está permitido como `OWNER`, que es exactamente lo 
que pasamos como `OWNER` en nuestra prueba.

Efectivamente, se pueden encontrar más pistas en `main/resources/schema.sql`, que configura nuestras tablas de base de datos:

```sql
CREATE TABLE cash_card
(
...
OWNER    VARCHAR(256) NOT NULL
);
```
Qué significa todo esto? Significa que aunque las pruebas (y los usuarios) ven un error `403 FORBIDDEN`, la aplicación realmente está fallando!

Entonces, ¿por qué no vemos un `500 INTERNAL_SERVER_ERROR`, que es más apropiado para un servidor que falla?

#### Learning Moment: Spring Security and Error Handling

Nuestro Controller está devolviendo un `403 FORBIDDEN` en lugar de un `500 INTERNAL_SERVER_ERROR` porque **Spring Security** está implementando una buena práctica sobre cómo manejar errores en **Spring Web**.

Es importante entender que cualquier información devuelta por nuestra aplicación podría ser útil para un malicioso actor que intente violar la 
seguridad de nuestra aplicación. Por ejemplo: conocimiento de las acciones que causan que la aplicación se bloquee -- un `500 INTERNAL_SERVER_ERROR`.

Para evitar "revelar" información sobre nuestra aplicación, **Spring Security** ha configurado **Spring Web** para devolver un error genérico `403 FORBIDDEN` en la mayoría de los casos de error.

Ahora que entendemos lo que está sucediendo, hagamos que el `Controller` se comporte de la manera correcta.

### 3. Actualice el endpoint `POST` en el controller.

Una vez más, usaremos el Principal proporcionado para asegurarnos de que se guarde al propietario correcto con la nueva `CashCard`.

```java
@PostMapping
private ResponseEntity<Void> createCashCard(@RequestBody CashCard newCashCardRequest, UriComponentsBuilder ucb, Principal principal) {
  CashCard cashCardWithOwner = new CashCard(null, newCashCardRequest.amount(), principal.getName());
  CashCard savedCashCard = cashCardRepository.save(cashCardWithOwner);
  ...
```

### 4. Ejecuta las pruebas.

¡Todos pasan!

```shell
    BUILD SUCCESSFUL in 7s
```

Ahora solo se utiliza el Principal autorizado y autenticado para crear una `CashCard`.

# About CSRF

Como aprendimos en la lección adjunta, la protección contra la falsificación de solicitudes entre sitios (`CSRF` o "`sea-surf`") es un aspecto importante de las `API` basadas en **HTTP** utilizadas por las aplicaciones basadas en web.

Sin embargo, hemos desactivado `CSRF` mediante el código `csrf.disable()` en `SecurityConfig.filterChain`.

¿Por qué hemos desactivado `CSRF`?

Para los fines de nuestra `API Family Cash Card`, seguiremos las instrucciones del equipo de **Spring Security** con [respecto a los clientes](https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/csrf.html#when-to-use-csrf-protection) 
que no utilizan navegador:

> ¿Cuándo debería utilizar la protección CSRF? Nuestra recomendación es utilizar protección CSRF para cualquier solicitud que pueda ser procesada 
> por un navegador por parte de los usuarios normales. Si solo está creando un servicio que utilizan clientes que no son de navegador, es probable que desee desactivar la protección CSRF.

Si desea agregar seguridad `CSRF` a nuestra aplicación, revise las opciones de soporte de prueba a continuación.

- [Ejemplos de prueba de `MockMVC CSRF`.](https://docs.spring.io/spring-security/reference/servlet/test/mockmvc/csrf.html)
- [Ejemplos de pruebas de `WebTestClient CSRF`.](https://docs.spring.io/spring-security/site/docs/5.2.0.RELEASE/reference/html/test-webflux.html#csrf-support)
- Una descripción del [patrón de cookies de envío doble (Double-Submit Cookie Pattern)](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie).

# Summary

En esta práctica de laboratorio, aprendió a utilizar **Spring Security** para garantizar que solo los usuarios autenticados y autorizados tengan 
acceso a la `API` de **Family Cash Card**. Además, siguió las mejores prácticas en las capas de `Controller` y `Repository` de nuestra aplicación para 
garantizar que solo los usuarios correctos tengan acceso a sus (y solo a sus) datos de `CashCard`. También aprendió que `Spring Security` no solo protege 
nuestras solicitudes, sino que también modifica el manejo de errores de nuestra `API` para evitar "filtrar" información sobre fallas y otras operaciones internas que ocurren con nuestra aplicación.