# Changes from Previous Workshops
Si ha tomado los laboratorios anteriores en este curso, notará los siguientes cambios, que necesitamos realizar para que este laboratorio sea más fácil de entender y completar.
## Test Resource Files
Hemos proporcionado los siguientes archivos que utilizará en este laboratorio.
- `src/main/resources/schema.sql`
- `src/test/resources/data.sql`

Cree ambos archivos en las carpetas correspondientes y agregue la siguiente data a estos:

- `schema.sql`:
```sql
/*

CREATE TABLE cash_card

(

ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

AMOUNT NUMBER NOT NULL DEFAULT 0

);

*/
```

- `data.sql`:
```sql
/*

INSERT INTO CASH_CARD(ID, AMOUNT) VALUES (99, 123.45);

*/
```

# Review the Current Data Management Pattern

Nuestra **API REST** de **Family Cash Card** se basa actualmente en los datos de `CashCard` codificados directamente en nuestro `CashCardController`. Nuestras pruebas en `CashCardApplicationTests` afirman que estos datos están presentes.

Sabemos que un controlador web no debería gestionar los datos. Esto es una violación de la separación de preocupaciones. El tráfico web es tráfico web, los datos son datos y el software saludable tiene arquitecturas dedicadas a cada área.

### 1. Revise `CashCardController`.
Tenga en cuenta líneas como las siguientes:
```java
... 

if (requestedId.equals(99L)) {
CashCard cashCard = new CashCard(99L, 123.45);
return ResponseEntity.ok(cashCard); 

...
```
Esto es gestión de datos. Nuestro Controlador no debería preocuparse por verificar las ID o crear datos.

### 2. Revise `CashCardApplicationTests`.
Curiosamente, si bien nuestras pruebas hacen afirmaciones sobre los datos, no se basan ni especifican cómo se crean o gestionan esos datos.

Este desacoplamiento es importante, ya que nos ayuda a hacer los cambios que necesitamos.

### Prepare to Refactor to use a Repository and Database
La refactorización es el acto de alterar la implementación de un sistema de software sin alterar sus entradas, salidas o comportamiento.

Nuestras pruebas nos permitirán cambiar la implementación de la gestión de datos de nuestra **API** de `CashCard` de datos codificados dentro de nuestro controlador, a la utilización de un repositorio y una base de datos.

Este laboratorio es un ejemplo continuo del bucle de desarrollo de **Red, Green, Refactor** que aprendimos en una lección anterior.

A medida que refactorizamos, nuestras pruebas fallarán periódicamente cuando las ejecutemos. Sabremos que hemos eliminado con éxito todos los datos codificados de nuestro Controlador y hemos "migrado" esos datos (y la gestión de datos) a un repositorio respaldado por la base de datos cuando nuestras pruebas vuelvan a pasar.

# Add Spring Data Dependencies

Este proyecto se creó originalmente utilizando el **Spring Initializr**, que nos permitió añadir automáticamente dependencias a nuestro proyecto. Sin embargo, ahora debemos añadir manualmente dependencias a nuestro proyecto.

### 1. Añade dependencias para **Spring Data** y una base de datos.
En `build.gradle`:
```groovy
dependencies { 
	implementation 'org.springframework.boot:spring-boot-starter-web'
	testImplementation 'org.springframework.boot:spring-boot-starter-test' // Add the two dependencies below implementation 
	'org.springframework.data:spring-data-jdbc' 
	implementation 'com.h2database:h2' 
}
```

### 2. Entendiendo las dependencias.
Las dos dependencias que añadimos están relacionadas, pero son diferentes.
```groovy
implementation 'org.springframework.data:spring-data-jdbc'
```

**Spring Data** tiene muchas implementaciones para una variedad de tecnologías de bases de datos relacionales y no relacionales. **Spring Data** también tiene varias abstracciones además de esas tecnologías. Estos se denominan comúnmente un marco de **mapeo objeto-relacional (object relational-mapping)**, o **ORM**.

Aquí elegiremos usar **Spring Data JDBC**. De la [documentación](https://spring.io/projects/spring-data-jdbc) de **Spring Data JDBC**:

>  Spring Data JDBC aims at being conceptually easy...
>  This makes Spring Data JDBC a simple, limited, opinionated ORM.

```groovy
    implementation 'com.h2database:h2'
```

Los marcos de gestión de bases de datos solo funcionan si tienen una base de datos vinculada. **H2** es una base de datos **SQL** "muy rápida y de código abierto, **API JDBC**" implementada en **Java**. Funciona a la perfección con **Spring Data JDBC**.

### 3. Corre los tests.
Esto instalará las dependencias y verificará que su adición no haya roto nada.

Siempre usaremos la prueba `./gradlew` para ejecutar nuestras pruebas.
```shell
[~/exercises] $ ./gradlew test
...
BUILD SUCCESSFUL in 4s
```

¡Las dependencias ya están instaladas! Es posible que note una salida adicional en comparación con los laboratorios anteriores, como el cierre de la base de datos integrada.

**Spring Auto Configuration** ahora está iniciando y configurando una base de datos **H2** para que la usemos con las pruebas. ¡Genial!

# Create the CashCardRepository

### 1. Crea la clase `CashCardRepository`.
Crea `src/main/java/example/cashcard/CashCardRepository.java` y ha que se extienda `CrudRepository`.
```java
    package example.cashcard;
    
    import org.springframework.data.repository.CrudRepository;
    
    interface CashCardRepository extends CrudRepository {
    }
```

### 2. Entendiendo `extends CrudRepository`.
Aquí es donde aprovechamos la magia de **Spring Data** y su patrón de repositorio de datos.

`CrudRepository` es una interfaz proporcionada por **Spring Data**. Cuando lo ampliamos (u otras subinterfaces del repositorio de **Spring Data**), **Spring Boot** y **Spring Data** trabajan juntos para generar automáticamente los métodos **CRUD** que necesitamos para interactuar con una base de datos.

Utilizaremos uno de estos métodos **CRUD**, `findById`, más adelante en el laboratorio.

### 3. Ejecuta las pruebas.
Podemos ver que todo se compila, sin embargo, nuestra aplicación se bloquea gravemente al iniciarse. Buscando en los mensajes de error, encontramos esto:
```shell
[~/exercises] $ ./gradlew test
...
CashCardApplicationTests > shouldNotReturnACashCardWithAnUnknownId() FAILED
 java.lang.IllegalStateException: Failed to load ApplicationContext for ...

Caused by:
java.lang.IllegalArgumentException: Could not resolve domain type of interface example.cashcard.CashCardRepository
...
```

Este error críptico significa que no hemos indicado qué objeto de datos debe administrar el `CashCardRepository`. Para nuestra aplicación, el "domain type" de este repositorio será la `CashCard`.

### 4. Configure el `CashCardRepository`.
Edite el `CashCardRepository` para especificar que administra los datos de la `CashCard` y que el tipo de datos del **ID** de la `CashCard` es largo.
```java
    interface CashCardRepository extends CrudRepository<CashCard, Long> {
    }
```

### 5. Configure la `CashCard`.
Cuando configuramos el repositorio como `CrudRepository<CashCard, Long>`, indicamos que el **ID** de `CashCard` es `Long`. Sin embargo, todavía tenemos que decirle a **Spring Data** qué campo es el **ID**.

Edite la clase `CashCard` para configurar el id como el `@Id` para el `CashCardRepository`.

No olvides añadir la nueva importación.

```java
    package example.cashcard;
    
    // Add this import
    import org.springframework.data.annotation.Id;
    
    record CashCard(@Id Long id, Double amount) {
    }
```

### 6. Corre las pruebas.

```shell
[~/exercises] $ ./gradlew test
...
BUILD SUCCESSFUL in 4s
```

Las pruebas pasan, pero no hemos hecho ningún cambio significativo en el código... ¡todavia!

# Inject the CashCardRepository

Aunque hemos configurado nuestras clases `CashCard` y `CashCardRepository`, no hemos utilizado el nuevo `CashCardRepository` para gestionar nuestros datos de `CashCard`. Hagámoslo ahora.

### 1. Inyecte el `CashCardRepository` en `CashCardController`.
Edita `CashCardController` para aceptar un `CashCardRepository`.
```java
@RestController
@RequestMapping("/cashcards")
class CashCardController {
   private final CashCardRepository cashCardRepository;

   private CashCardController(CashCardRepository cashCardRepository) {
      this.cashCardRepository = cashCardRepository;
   }
   ...
```

### 2. Ejecuta las pruebas.
Si ejecutas las pruebas ahora, todas pasarán, a pesar de que no hay otros cambios en la base de código utilizando el nuevo constructor requerido `CashCardController (CashCardRepository cashCardRepository)`.

```shell
BUILD SUCCESSFUL in 7s
```

### 3. Entonces, ¿cómo es esto posible?

¡He aquí la configuración automática y la inyección de construcción!

La configuración automática de **Spring** está utilizando su marco de inyección de dependencias **(DI)**, específicamente la inyección de constructores, para proporcionar a `CashCardController` la implementación correcta de `CashCardRepository` en tiempo de ejecución.

¡Cosas mágicas!

#### Learning Moment: Remove the DI

Acabamos de ver la gloria de la configuración automática y la inyección del constructor.

Pero, ¿qué pasa cuando desactivamos esta maravilla?

### 1. Cambie temporalmente el `CashCardRepository` para eliminar la implementación de `CrudRepository`.
```java
    interface CashCardRepository {
    }
```

### 2. Compile el proyecto y note el fallo.

```shell
[~/exercises] $ ./gradlew build
```

Buscando en la salida, encontramos esta línea:

```shell
org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'example.cashcard.CashCardRepository' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
```

Pistas como `NoSuchBeanDefinitionException`, `No qualifying bean`, y `expected at least 1 bean which qualifies as autowire candidate` nos dicen que **Spring** está tratando de encontrar una clase correctamente configurada para proporcionar durante la fase de inyección de dependencias de **Auto Configuration**, pero ninguna califica.

Podemos satisfacer este requisito de **DI** extendiendo el **CrudRepository**.

### 3. Deshaz todo.
```java
interface CashCardRepository extends CrudRepository<CashCard, Long> { }
```

# Use the CashCardRepository for Data Management

¡Por fin estás listo para usar el `CashCardRepository`!

### 1. Encuentra la `CashCard` usando `findById`.

La interfaz de `CrudRepository` proporciona muchos métodos útiles, incluyendo `findById(ID id)`.

Actualice el `CashCardController` para utilizar este método en el `CashCardRepository` y actualice la lógica; asegúrese de importar `java.util.Optional`;

```java
    import java.util.Optional;
    ...
    @GetMapping("/{requestedId}")
    private ResponseEntity<CashCard> findById(@PathVariable Long requestedId) {
        Optional<CashCard> cashCardOptional = cashCardRepository.findById(requestedId);
        if (cashCardOptional.isPresent()) {
            return ResponseEntity.ok(cashCardOptional.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }
```

### 2. Entender los cambios.

Acabamos de alterar `CashCardController.findById` de varias maneras importantes.

```java
Optional<CashCard> cashCardOptional = cashCardRepository.findById(requestedId);
```

Estamos llamando a `CrudRepository.findById`, que devuelve un `Optional`. Este objeto inteligente puede o no contener la `CashCard` que estamos buscando. Obtenga más información sobre `Opcional` [aquí](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html).

```java
cashCardOptional.isPresent()
```

y

```java
cashCardOptional.get()
```

Así es como se determina si `findById` encontró o no la `CashCard` con la identificación proporcionada.

Si `cashCardOptional.isPresent()` es verdadero, entonces el repositorio encontró con éxito la `CashCard` y podemos recuperarla con `cashCardOptional.get()`.

Si no, el repositorio no ha encontrado la `CashCard`.

### 3. Ejecuta las pruebas.

Podemos ver que las pruebas fallan con un `500 INTERNAL_SERVER_ERROR`.

```shell
CashCardApplicationTests > shouldReturnACashCardWhenDataIsSaved() FAILED
   org.opentest4j.AssertionFailedError:
   expected: 200 OK
   but was: 500 INTERNAL_SERVER_ERROR
```

Esto significa que la API de la `CashCard` "se bloqueó".

Necesitamos un poco más de información...

Actualicemos temporalmente la sección de salida de prueba de `build.gradle` con `showStandardStreams = true`, para que nuestras ejecuciones de prueba produzcan mucha más salida.

```groovy
    test {
     testLogging {
         events "passed", "skipped", "failed" //, "standardOut", "standardError"
    
         showExceptions true
         exceptionFormat "full"
         showCauses true
         showStackTraces true
    
         // Change from false to true
         showStandardStreams = true
     }
    }
```

### 4. Vuelve a ejecutar las pruebas.

Tenga en cuenta que la salida de la prueba es mucho más detallada.

Al buscar en la salida, encontramos estos fallos:

```shell
org.h2.jdbc.JdbcSQLSyntaxErrorException: Table "CASH_CARD" not found (this database is empty);
SQL statement:
 SELECT "CASH_CARD"."ID" AS "ID", "CASH_CARD"."AMOUNT" AS "AMOUNT" FROM "CASH_CARD" WHERE "CASH_CARD"."ID" = ? [42104-214]
```

La causa de nuestros fallos de prueba está clara: `Table "CASH_CARD" not found` significa que no tenemos una base de datos ni ningún dato.

#  Configure the Database

Nuestras pruebas esperan que la **API** encuentre y devuelva una `CashCard` con una identificación de `99`. Sin embargo, acabamos de eliminar los datos de `CashCard` codificados y los reemplazamos con una llamada a `cashCardRepository.findById`.

Ahora nuestra aplicación se bloquea, quejándose de que falta una tabla de base de datos llamada `CASH_CARD`:

```shell
org.h2.jdbc.JdbcSQLSyntaxErrorException: Table "CASH_CARD" not found (this database is empty);
```

Necesitamos ayudar a **Spring Data** a configurar la base de datos y cargar algunos datos de muestra, como nuestro amigo, `CashCard 99`.

**Spring Data** y **H2** pueden crear y rellenar automáticamente la base de datos en memoria que necesitamos para nuestra prueba. Te hemos proporcionado estos archivos, pero tendrás que modificarlos: `schema.sql` y `data.sql`.

Nota: Proporcionar `schema.sql` y `data.sql` es una de las muchas formas en que **Spring** proporciona para inicializar fácilmente una base de datos. Para obtener más información, lea la [documentación de Spring Framework](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization.using-basic-sql-scripts).

### 1. Editar `schema.sql`.

Como se mencionó anteriormente, **Spring Data** configurará automáticamente una base de datos para las pruebas si proporcionamos el archivo correcto en la ubicación correcta.

¡Y lo hemos hecho! Es `src/main/resources/schema.sql`.

Pero, actualmente está desactivado.

Edite `src/main/resources/schema.sql` y elimine el comentario en bloque `/* ... */`.

```sql
    CREATE TABLE cash_card
    (
       ID     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       AMOUNT NUMBER NOT NULL DEFAULT 0
    );
```

### 2. Entender schema.sql.

Un esquema de base de datos es un "plan" de cómo se almacenan los datos en una base de datos. Aquí no cubriremos los esquemas de la base de datos en profundidad.

Nuestro esquema de base de datos refleja el objeto `CashCard` que entendemos, que contiene un identificador y una cantidad.

### 3. Vuelve a ejecutar las pruebas.

Nota: Si la salida de la prueba es demasiado detallada, revierta el cambio en `build.gradle` realizado anteriormente.

Nuestras pruebas ya no se bloquean con un `500 INTERNAL_SERVER_ERROR`. Sin embargo, ahora tenemos un `404 NOT_FOUND`

```shell
CashCardApplicationTests > shouldReturnACashCardWhenDataIsSaved() FAILED
 org.opentest4j.AssertionFailedError:
 expected: 200 OK
  but was: 404 NOT_FOUND
```

Traducción: Nuestro repositorio no puede encontrar `CashCard` con una identificación de `99`. Entonces, ¿por qué no?

Aunque hemos ayudado a **Spring Data** a crear una base de datos de prueba al deshacer comentarios de `schema.sql`, sigue siendo una base de datos vacía.

¡Vamos a cargar algunos datos!

### 4. Cargar datos de prueba desde data.sql.

**Spring Data** no solo puede crear nuestra base de datos de pruebas, sino que también puede cargar datos en ella, que podemos usar en nuestras pruebas.

Al igual que `schema.sql`, hemos proporcionado `src/test/resources/data.sql`, pero su contenido también está comentado.

Eliminemos los comentarios del bloque en `src/test/resources/data.sql`.

```sql
INSERT INTO CASH_CARD(ID, AMOUNT) VALUES (99, 123.45);
```

Esta declaración `SQL` inserta una fila en la tabla `CASH_CARD` con un `ID=99` y `AMOUNT=123.45`, que coincide con los valores que esperamos en nuestras pruebas.

### 5. Corra los test otra vez.

Estos pasan! Wooo Hooo!

```shell
    [~/exercises] $ ./gradlew test
    ...
    BUILD SUCCESSFUL in 7s
```

¡Éxito! Ahora estamos utilizando datos reales en nuestra **API**.

#### Learning Moment: `main` vs `test` resources

¿Has notado que `src/main/resources/schema.sql` y `src/test/resources/data.sql` están en diferentes ubicaciones de recursos?

¿Puedes adivinar por qué es esto?

Recuerde que nuestra `CashCard` con `ID 99` y cantidad `123.45` es una `CashCard` falsa e inventada que solo queremos usar en nuestras pruebas. No queremos que nuestro sistema "real" o de producción cargue la `CashCard` `99` en el sistema... ¿qué pasaría con la `CashCard` `99` real?

Spring nos ha proporcionado una característica poderosa: nos permite separar nuestros recursos solo de prueba de nuestros recursos principales cuando sea necesario.

Nuestro escenario aquí es un ejemplo común de esto: nuestro esquema de base de datos es siempre el mismo, ¡pero nuestros datos no lo son!

¡Gracias de nuevo, **Spring**!

#  Summary

Ahora has refactorizado con éxito la forma en que la **API** de **Family Cash Card** gestiona sus datos. **Spring Data** ahora está creando una base de datos **H2** en memoria y cargándola con datos de prueba, que nuestras pruebas utilizan para ejercer nuestra **API**.

Además, ¡no cambiamos ninguna de nuestras pruebas! De hecho, nos guiaron a una implementación correcta. ¡¿Qué tan increíble es eso?!